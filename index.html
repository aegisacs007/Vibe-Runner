<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VIBE RUNNER 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); color: #00ffcc;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 10; text-align: center;
        }
        h1 { font-size: 40px; text-shadow: 0 0 20px #00ffcc; margin-bottom: 10px; }
        p { font-size: 14px; color: #fff; max-width: 300px; line-height: 1.5; margin-bottom: 30px; }
        #start-btn {
            padding: 15px 40px; background: #00ffcc; color: #000;
            border: none; font-size: 18px; font-weight: bold; border-radius: 30px;
            cursor: pointer; box-shadow: 0 0 30px #00ffcc; animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.05);} 100% {transform: scale(1);} }
        #hud {
            position: absolute; top: 10px; left: 10px; color: #00ffcc;
            font-size: 16px; font-weight: bold; z-index: 5; pointer-events: none;
            text-shadow: 0 0 5px #00ffcc;
        }
        #mic-status {
            position: absolute; bottom: 10px; left: 0; width: 100%;
            text-align: center; color: #555; font-size: 10px; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>VIBE RUNNER</h1>
        <p>ðŸ”Š MICROPHONE REQUIRED<br><br>Scream, Clap, or Sing to open the tunnel.<br>Silence = Game Over.</p>
        <button id="start-btn">ACTIVATE MIC & RUN</button>
    </div>

    <div id="hud">SCORE: <span id="score">0</span></div>
    <div id="mic-status">Waiting for audio input...</div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // State
        let gameRunning = false;
        let score = 0;
        let speed = 0.4;
        let cameraZ = 0;

        // Audio
        let audioContext, analyser, dataArray;
        let currentVolume = 0;

        // --- PLAYER ---
        const playerGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const playerMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
        const player = new THREE.Mesh(playerGeo, playerMat);
        scene.add(player);
        
        const playerLight = new THREE.PointLight(0x00ffcc, 1.5, 10);
        player.add(playerLight);

        let targetX = 0; let targetY = 0;
        player.position.z = -5;

        // --- TUNNEL ---
        const tunnelParticles = 4000;
        const tunGeo = new THREE.BufferGeometry();
        const positions = [];
        const rads = [];

        for (let i = 0; i < tunnelParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 4 + Math.random() * 3; // Base width
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            const z = (Math.random() - 0.5) * 300; // Tunnel length
            positions.push(x, y, z);
            rads.push(radius);
        }

        tunGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        const tunMat = new THREE.PointsMaterial({
            color: 0xff0055, size: 0.15, transparent: true, opacity: 0.8
        });
        const tunnel = new THREE.Points(tunGeo, tunMat);
        scene.add(tunnel);

        // --- CONTROLS ---
        document.addEventListener('touchmove', (e) => {
             e.preventDefault();
             targetX = (e.touches[0].clientX / window.innerWidth) * 6 - 3;
             targetY = -(e.touches[0].clientY / window.innerHeight) * 6 + 3;
        }, { passive: false });
        
        document.addEventListener('mousemove', (e) => {
            targetX = (e.clientX / window.innerWidth) * 6 - 3;
            targetY = -(e.clientY / window.innerHeight) * 6 + 3;
        });

        // --- START GAME ---
        document.getElementById('start-btn').addEventListener('click', async () => {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const mic = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 64;
                mic.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('mic-status').innerText = "AUDIO ENGINE: ACTIVE";
                gameRunning = true;
                animate();
            } catch (err) {
                alert("Please allow Microphone access! The game needs sound to work.");
            }
        });

        // --- LOOP ---
        function animate() {
            if (!gameRunning) return;
            requestAnimationFrame(animate);

            // 1. Get Volume
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for(let i=0; i<dataArray.length; i++) sum += dataArray[i];
            currentVolume = sum / dataArray.length / 50; // Normalize

            // 2. Expand Tunnel
            const positions = tunnel.geometry.attributes.position.array;
            const expansion = 1 + (currentVolume * 2.5); // Multiplier

            for (let i = 0; i < tunnelParticles; i++) {
                const i3 = i * 3;
                const baseRad = rads[i];
                const x = positions[i3];
                const y = positions[i3 + 1];
                let z = positions[i3 + 2];

                // Recalculate radius based on volume
                const angle = Math.atan2(y, x);
                const newRad = baseRad * expansion;
                
                positions[i3] = Math.cos(angle) * newRad;
                positions[i3+1] = Math.sin(angle) * newRad;

                // Infinite Scroll
                if (z > cameraZ + 5) {
                    positions[i3+2] = z - 300;
                }
            }
            tunnel.geometry.attributes.position.needsUpdate = true;

            // Colors: Quiet=Red, Loud=Blue
            const hue = currentVolume > 0.3 ? 0.6 : 0.0;
            tunnel.material.color.setHSL(hue, 1.0, 0.5);

            // 3. Move
            cameraZ -= speed;
            camera.position.z = cameraZ;
            player.position.z = cameraZ - 5;
            
            // Smooth Steering
            player.position.x += (targetX - player.position.x) * 0.1;
            player.position.y += (targetY - player.position.y) * 0.1;

            score++;
            document.getElementById('score').innerText = score;
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
