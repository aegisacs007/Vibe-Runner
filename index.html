<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VIBE RUNNER: NEON</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: #00ffcc;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 10; text-align: center;
        }
        
        h1 { font-size: 40px; text-shadow: 0 0 20px #00ffcc; margin-bottom: 10px; }
        p { font-size: 14px; color: #fff; max-width: 300px; line-height: 1.5; margin-bottom: 30px; }
        
        #start-btn {
            padding: 20px 40px; background: #00ffcc; color: #000;
            border: none; font-size: 18px; font-weight: bold; border-radius: 50px;
            cursor: pointer; box-shadow: 0 0 30px #00ffcc; animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.05);} 100% {transform: scale(1);} }
        
        /* HUD ON TOP */
        #hud-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; }
        #score-display {
            position: absolute; top: 20px; left: 20px; color: #00ffcc;
            font-size: 20px; font-weight: bold; text-shadow: 0 0 10px #00ffcc;
        }
        #status-display {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: #555; font-size: 12px;
        }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>VIBE RUNNER</h1>
        <p>ðŸ”Š MIC REQUIRED<br>Make noise to survive.</p>
        <button id="start-btn">TAP TO START</button>
    </div>

    <div id="hud-layer">
        <div id="score-display">SCORE: 0</div>
        <div id="status-display">Waiting for start...</div>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.136.0/build/three.module.js';

        // --- SETUP ---
        const scene = new THREE.Scene();
        // Set Background to Dark Blue so we KNOW if it renders
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false }); // False for better mobile performance
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- VARIABLES ---
        let gameRunning = false;
        let score = 0;
        let speed = 0.6;
        let cameraZ = 0;
        let audioContext, analyser, dataArray;
        let currentVolume = 0;
        let targetX = 0; 
        let targetY = 0;

        // --- PLAYER (The Glowing Cube) ---
        const playerGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const playerMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
        const player = new THREE.Mesh(playerGeo, playerMat);
        scene.add(player);
        player.position.z = -5;
        
        // Add a "trail" light
        const light = new THREE.PointLight(0x00ffcc, 1, 20);
        player.add(light);

        // --- THE TUNNEL (Big Particles) ---
        const tunnelParticles = 2000;
        const tunGeo = new THREE.BufferGeometry();
        const positions = [];
        const rads = [];

        for (let i = 0; i < tunnelParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 5 + Math.random() * 5; // Wider tunnel
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            const z = (Math.random() - 0.5) * 400; 
            positions.push(x, y, z);
            rads.push(radius);
        }

        tunGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        
        // BIGGER PARTICLES for visibility
        const tunMat = new THREE.PointsMaterial({
            color: 0xff0055, 
            size: 0.8, // Much bigger size
            transparent: true, 
            opacity: 0.9
        });
        const tunnel = new THREE.Points(tunGeo, tunMat);
        scene.add(tunnel);

        // --- INPUTS ---
        document.addEventListener('touchmove', (e) => {
             e.preventDefault();
             targetX = (e.touches[0].clientX / window.innerWidth) * 10 - 5;
             targetY = -(e.touches[0].clientY / window.innerHeight) * 10 + 5;
        }, { passive: false });
        
        document.addEventListener('mousemove', (e) => {
            targetX = (e.clientX / window.innerWidth) * 10 - 5;
            targetY = -(e.clientY / window.innerHeight) * 10 + 5;
        });

        // --- START ---
        document.getElementById('start-btn').addEventListener('click', async () => {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const mic = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 64;
                mic.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('status-display').innerText = "AUDIO ENGINE: ACTIVE";
                gameRunning = true;
                animate();
            } catch (err) {
                alert("Microphone denied! Running in silent mode (Demo).");
                document.getElementById('start-screen').style.display = 'none';
                gameRunning = true;
                animate();
            }
        });

        // --- LOOP ---
        function animate() {
            if (!gameRunning) return;
            requestAnimationFrame(animate);

            // Audio Logic
            if(analyser) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i=0; i<dataArray.length; i++) sum += dataArray[i];
                currentVolume = sum / dataArray.length / 50; 
            } else {
                currentVolume = 0.5; // Auto-volume for demo mode
            }

            // Expand Tunnel Logic
            const positions = tunnel.geometry.attributes.position.array;
            const expansion = 1 + (currentVolume * 2); 

            for (let i = 0; i < tunnelParticles; i++) {
                const i3 = i * 3;
                const baseRad = rads[i];
                const x = positions[i3];
                const y = positions[i3 + 1];
                let z = positions[i3 + 2];

                const angle = Math.atan2(y, x);
                const newRad = baseRad * expansion;
                
                positions[i3] = Math.cos(angle) * newRad;
                positions[i3+1] = Math.sin(angle) * newRad;

                if (z > cameraZ + 5) {
                    positions[i3+2] = z - 400; // Reset far ahead
                }
            }
            tunnel.geometry.attributes.position.needsUpdate = true;
            
            // Color Shift
            const hue = currentVolume > 0.4 ? 0.6 : 0.0;
            tunnel.material.color.setHSL(hue, 1.0, 0.5);

            // Move
            cameraZ -= speed;
            camera.position.z = cameraZ;
            player.position.z = cameraZ - 5;
            
            // Steer
            player.position.x += (targetX - player.position.x) * 0.1;
            player.position.y += (targetY - player.position.y) * 0.1;

            score++;
            document.getElementById('score-display').innerText = "SCORE: " + score;
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
